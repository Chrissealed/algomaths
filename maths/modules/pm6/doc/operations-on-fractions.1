.\" Automatically generated by Pandoc 2.1.2
.\"
.TH "" "" "" "" ""
.hy
.SH NAME
.PP
\f[B]OperationsOnFractions\f[] : \f[B]algomaths\f[] Perl 6 module in
/maths/modules/pm6/\f[B]operations\-on\-fractions.pm6\f[]
.SH AUTHOR
.PP
https://github.com/Chrissealed/algomaths.git
.SH VERSION
.PP
2019.01.04
.SH Ce module est destiné à faire des opérations sur des fractions.
.PP
Il utilise les modules \f[B]ppcm.pm6\f[],
\f[B]irreducible\-fraction.pm6\f[] et \f[B]prime\-factors.pm6\f[] et
hérite du rôle \f[B]PrimeFactors\f[].
La méthode principale de la classe \f[B]OperationsOnFractions\f[] est
\f[B]calculate\-fractions(Str
\f[BI]o\f[B]\f[BI]p\f[B]\f[BI]e\f[B]\f[BI]r\f[B]\f[BI]a\f[B]\f[BI]t\f[B]\f[BI]i\f[B]\f[BI]o\f[B]\f[BI]n\f[B]) *  * \f[BI]o\f[B]\f[BI]u\f[B]\f[BI]l\f[B]\f[BI]e\f[B]\f[BI]p\f[B]\f[BI]a\f[B]\f[BI]r\f[B]\f[BI]a\f[B]\f[BI]m\f[B]\f[BI]è\f[B]\f[BI]t\f[B]\f[BI]r\f[B]\f[BI]e\f[B] * *operation\f[]
peut être l'un des suivants :
.IP \[bu] 2
`add\-up' ou `+' ou `a',
.IP \[bu] 2
`subtract' ou `\-' ou `−' ou `s',
.IP \[bu] 2
`multiply' ou '*`ou'×`ou 'm',
.IP \[bu] 2
`divide' ou `:' ou `÷' ou `d',
.PP
ceci dans le cas ou il on opère que sur que deux fractions.
.PP
Elle renvoie une \f[B]paire\f[] (Pair) comme valeur de retour.
Les champs obligatoires à renseigner sont \f[B]nudepair1\f[], et
\f[B]nudepair2\f[], correspondant aux numérateur et dénominateur de
chaque fraction sur laquelle pratiquer l'opération choisie.
.PP
On peut justement se demander pourquoi l'implémentation des fractions se
fait par l'emploi du type \f[B]Pair\f[] plutôt que du type \f[B]Rat\f[]
(nombre rationnel) et que l'objet renvoyé par
\f[B]calculate\-fractions(Str $operation)\f[] est une paire et non une
fraction.
Cette implémentation est en fait sujette à la multiplication des options
pour le calcul des fractions; en effet les fractions littérales sont
automatiquement réduites à leur plus simple expression ce qui oblitère
la possibilité de choisir expressément la façon dont on veut effectuer
les calculs.
En fournissant les données sous cette forme, on a plus de contrôle sur
le déroulement des calculs, par exemple on a le choix de réduire ou pas
les fractions en entrée en fournissant une valeur True aux booléens
\f[B]reduce\-fractionN\f[] (Voir ci\-dessous).
De même on pourra choisir de livrer la dernière fraction résultante sans
la réduire systématiquement.
(Voir plus bas).
.PP
Le champ suivant est facultatif :
.IP \[bu] 2
\f[B]nudepair3\f[], pour lequel d'autres opérateurs sont disponibles
pour l'\f[B]addition\f[] et la \f[B]soustraction\f[] uniquement,
c'est\-à\-dire :
.IP \[bu] 2
`add\-upx2' ou `++' ou `aa',
.IP \[bu] 2
`subtractx2' ou `\[en]' ou `−−' ou `ss',
.IP \[bu] 2
`add\-up\-subtract' ou `+\-' ou `+−' ou `as', et enfin
.IP \[bu] 2
`subtract\-add\-up' ou `\-+' ou `−+' ou `sa'.
.PP
Ensuite, trois champs booléens facultatifs associés aux champs
\f[B]nudepair1\f[], \f[B]nudepair2\f[] et \f[B]nudepair3\f[] servent à
préciser si l'on effectue la réduction de la fraction en question avant
le traitement des données,
.IP \[bu] 2
ce sont \f[B]reduce\-fraction1\f[], \f[B]reduce\-fraction2\f[] et
\f[B]reduce\-fraction3\f[];
.PP
ces champs par défaut sont à \f[B]False\f[], autrement dit on ne tente
pas d'opérer une réduction de chaque fraction avant d'effectuer
l'opération.
Noter que la dernière fraction résultante de l'opération est toujours
donnée irréductible, mais qu'on peut jouer sur deux autres attributs
Booléens :
.IP \[bu] 2
\f[B]reduce\-last\-once\f[] (\f[B]False\f[] par défaut), et
\f[B]reduce\-last\-one\f[] (\f[B]True\f[] par défaut);
.PP
le premier visant dans le cadre de l'\f[B]\f[BI]addition\f[B]\f[] ou de
la \f[B]\f[BI]soustraction\f[B]\f[] à réduire une seule fois la première
fraction au terme du calcul dans une liste chaînée d'opérations (par
exemple : +−) lors du calcul de trois fractions, et le deuxième à
réduire systématiquement la dernière fraction obtenue à tous les niveaux
de cette liste ou bien lors d'une opération simple (+ ou −).
Ces attributs visent à modifier les opérations de calcul de manière à
produire plusieurs options pour générer un même résultat.
.PP
Six autres attributs, peuvent être utilisés lors d'une opération de
\f[B]\f[BI]multiplication\f[B]\f[] ou de \f[B]\f[BI]division\f[B]\f[],
pour une granularité maximale, ce sont :
.IP \[bu] 2
\f[B]breakdown\-numerator1\f[], réduire en facteurs premiers le
numérateur de la première fraction,
.IP \[bu] 2
\f[B]breakdown\-numerator2\f[], réduire en facteurs premiers le
numérateur de la deuxième fraction,
.IP \[bu] 2
\f[B]breakdown\-numerator3\f[], réduire en facteurs premiers le
numérateur de la troisième fraction facultative.
.IP \[bu] 2
\f[B]breakdown\-denominator1\f[], réduire en facteurs premiers le
dénominateur de la première fraction,
.IP \[bu] 2
\f[B]breakdown\-denominator2\f[], réduire en facteurs premiers le
dénominateur de la deuxième fraction,
.IP \[bu] 2
\f[B]breakdown\-denominator3\f[], réduire en facteurs premiers le
dénominateur de la troisième fraction facultative.
.PP
Ces six attributs ont par défaut la valeur \f[B]False\f[].
.PP
Viennent ensuite deux autres champs facultatifs utilisables pour la
\f[B]\f[BI]multiplication\f[B]\f[] ou la \f[B]\f[BI]division\f[B]\f[] de
fractions uniquement et qui jouent avec les six attributs décrits
précédemment :
.IP \[bu] 2
\f[B]breakdown\-numerators\f[]
.IP \[bu] 2
\f[B]breakdown\-denominators\f[]
.PP
qui pour le premier réduit en facteurs premiers les numérateurs de
chaque fraction et le deuxième réduit en facteurs premiers les
dénominateurs de chaque fraction; ces attributs sont tous les deux à
\f[B]True\f[] par défaut.
.PP
Vous disposez ainsi de deux niveaux de contrôle, l'un global pour tous
les numérateurs et/ou dénominateurs et l'autre pour un contrôle dont la
granularité vous permet d'agir exactement sur les numérateurs et/ou
dénominateurs de chaque fraction séparément.
.PP
Note: chaque fois que vous mettez à \f[B]True\f[] l'un des six attributs
granulaires, l'attribut global correspondant (c'est\-à\-dire
\f[B]breakdown\-numerators\f[] et/ou \f[B]breakdown\-denominators\f[])
est automatiquement désactivé.
.IP \[bu] 2
L'attribut \f[B]compute\-prime\-factors\f[]
.PP
enfin permet de supprimer les facteurs en double dans le numérateur et
le dénominateur de deux fractions pour opérer leur réduction.
Ce champ est à \f[B]True\f[] par défaut lui aussi.
.PP
Les autres champs, facultatifs, sont destinés à choisir parmi les
diverses méthodes utilisées pour le calcul des méthodes de classes
appelées en interne :
.IP \[bu] 2
\f[B]which\-ppcm\-algorithm\f[], peut prendre l'une des valeurs
suivantes :
.IP \[bu] 2
`by\-larger\-number\-multiples' ou `b.l.n.m.' ou `by\-m' ou `bm';
.IP \[bu] 2
`by\-prime\-factors' ou `b.p.f.' ou `by\-f' ou `bf';
.IP \[bu] 2
`by\-use\-of\-pgcd' ou `b.u.o.p.' ou `by\-p' ou `bp' (utilisé par
défaut).
.PP
Ce dernier attribut n'est \f[B]pas\f[] utilisé pour la
\f[B]\f[BI]multiplication\f[B]\f[] ou la \f[B]\f[BI]division\f[B]\f[],
mais uniquement pour l'\f[B]\f[BI]addition\f[B]\f[] ou la
\f[B]\f[BI]soustraction\f[B]\f[] afin de choisir l'algorithme qui sera
utilisé pour le calcul par la classe PPCM.
.IP \[bu] 2
\f[B]which\-irreducible\-fraction\-algorithm\f[] peut prendre les
valeurs :
.IP \[bu] 2
`euclide' ou `e' ou `:' ou `÷' (utilisé par défaut);
.IP \[bu] 2
`subtraction' ou `s' ou `\-' ou `−';
.IP \[bu] 2
`factorization' ou `f' ou '*`ou'×'.
.PP
Cet attribut est destiné à choisir la méthode qui sera utilisée par la
classe \f[B]IrreducibleFraction\f[] pour la réduction d'une fraction à
sa plus simple expression.
.IP \[bu] 2
\f[B]which\-pgcd\-algorithm\f[] peut prendre l'une des valeurs :
.IP \[bu] 2
`euclide' ou `e' ou `:' ou `÷' (utilisé par défaut);
.IP \[bu] 2
`subtraction' ou `s' ou `\-' ou `−';
.IP \[bu] 2
`factorization' ou `f' ou '*`ou'×';
.IP \[bu] 2
`divisors\-listing' ou `d' ou `#' ou `/'.
.PP
Cet attribut peut être employé pour toutes les opérations; il détermine
l'algorithme utilisé par la classe PGCD pour le calcul du PPCM.
.PP
La classe possède en outre un \f[B]attribut requis\f[] destiné à écrire
dans un fichier les informations qui apparaissent à l'écran et qui
décrivent les différentes étapes des opérations laissant ainsi un
\f[I]témoin\f[] du calcul effectué.
Celui\-ci (pour info) est défini dans le rôle sous\-jacent
\f[B]PrimeFactors\f[].
Il s'agit de \f[B]Teeput::Tput $t is required is rw\f[] : il faut lui
passer un objet de type \f[B]Teeput::Tput\f[] du module
\f[B]teeput.pm6\f[].
Ses méthodes sont utilisées en remplacement des méthodes
\f[B]\f[BI]put\f[B]\f[] (tput), \f[B]\f[BI]print\f[B]\f[] (tprint) ou
\f[B]\f[BI]say\f[B]\f[] (tsay).
Référez\-vous à la doc de ce module pour plus d'informations.
.SH Voici la liste des méthodes de la classe OperationsOnFractions :
.SS calculate\-fractions(Str:D $operation \[en]> Pair:D)
.PP
Cette méthode est la principale de la classe, qui donne accès à toutes
les autres méthodes − bien que celles\-là ne soient pas privées et sont
donc accessibles isolément − en employant un seul argument, le type
d'opération à effectuer.
(Voir plus haut)
.SS are\-they\-prime(Int:D \@numerators, Int:D \@denominators \[en]>
Pair:D)
.PP
Cette méthode a pour but de déterminer si les numérateurs et les
dénominateurs sont des facteurs premiers.
Les arguments correspondant sont des tableaux de 2 ou 3 éléments.
Si oui, les attributs de la classe en lecture seule
\f[B]are\-prime\-nu\f[] et/ou \f[B]are\-prime\-de\f[] sont passés à
\f[B]True\f[].
La méthode renvoie une paire constituée de deux valeurs booléenes : la
première composante correspondant aux numérateurs et la deuxième au
dénominateurs.
.SS reduce\-fraction(Int:D $numerator, Int:D $denominator, Str $sign =
'' \[en]> Pair:D)
.PP
Cette méthode destinée à obtenir la fraction irréductible à partir du
numérateur et du dénominateur passés en argument utilise la classe
\f[B]IrreducibleFraction\f[] du module
\f[B]irreducible\-fraction.pm6\f[] et utilise deux attributs de la
classe, soit \f[B]which\-irreducible\-fraction\-algorithm\f[] et
\f[B]which\-pgcd\-algorithm\f[] qui déterminent le choix pour le premier
de l'algorithme de la méthode utilisée en interne par
\f[B]IrreducibleFraction\f[] pour effectuer les calculs, et pour le
deuxième l'algorithme du module \f[B]pgdc.pm6\f[] dont
\f[B]IrreducibleFraction\f[] se servira en interne.
Pour gérer correctement les nombres négatifs avec l'opération
\f[B]multiply\f[] uniquement, il faut mettre le troisième argument
\f[B]$sign\f[] à `\-' afin d'appeler l'une des méthodes
.IP \[bu] 2
\f[B]reduce\-fraction\-with\-euclide\-algorithm($sign)\f[];
.IP \[bu] 2
\f[B]reduce\-fraction\-with\-subtraction\-algorithm($sign)\f[]
.IP \[bu] 2
\f[B]reduce\-fraction\-with\-factorization\-algorithm(\f[BI]s\f[B]\f[BI]i\f[B]\f[BI]g\f[B]\f[BI]n\f[B]) * *;\f[BI]L\f[B]\f[BI]e\f[B]\f[BI]s\f[B]\f[BI]i\f[B]\f[BI]g\f[B]\f[BI]n\f[B]\f[BI]e\f[B] + \f[BI]n\f[B]′\f[BI]e\f[B]\f[BI]s\f[B]\f[BI]t\f[B]\f[BI]p\f[B]\f[BI]a\f[B]\f[BI]s\f[B]\f[BI]é\f[B]\f[BI]c\f[B]\f[BI]r\f[B]\f[BI]i\f[B]\f[BI]t\f[B], \f[BI]i\f[B]\f[BI]l\f[B]\f[BI]e\f[B]\f[BI]s\f[B]\f[BI]t\f[B]\f[BI]g\f[B]\f[BI]é\f[B]\f[BI]r\f[B]\f[BI]é\f[B]\f[BI]p\f[B]\f[BI]a\f[B]\f[BI]r\f[B]\f[BI]l\f[B]\f[BI]a\f[B]\f[BI]v\f[B]\f[BI]a\f[B]\f[BI]l\f[B]\f[BI]e\f[B]\f[BI]u\f[B]\f[BI]r\f[B]\f[BI]p\f[B]\f[BI]a\f[B]\f[BI]r\f[B]\f[BI]d\f[B]\f[BI]é\f[B]\f[BI]f\f[B]\f[BI]a\f[B]\f[BI]u\f[B]\f[BI]t\f[B]\f[BI]d\f[B]\f[BI]e\f[B] * *sign\f[],
une chaîne vide.
.SS add\-up(Pair:D $pair1, Pair:D $pair2, Int $times = 0 \[en]> Pair:D)
.PP
Cette méthode renvoie l'addition des numérateurs et dénominateurs passés
aux attributs de la classe, c'est\-à\-dire, \f[B]nudepair1\f[] et
\f[B]nudepair2\f[].
Elle utilise les modules \f[B]ppcm.pm6\f[] et \f[B]pgcd.pm6\f[], ainsi
que la méthode de la classe \f[B]reduce\-fraction\f[](Int:D $numerator,
Int:D $denominator, Str $sign = '' \[en]> Pair:D) {} par l'entremise de
laquelle sont appelées les méthodes du module
\f[B]irreducible\-fraction.pm6\f[].
.PP
Le paramètre \f[B]$times\f[] s'il est mis à 1 et que l'attribut de la
classe \f[B]reduce\-last\-on\f[]_c_e**** est passé à \f[B]True\f[], la
méthode ne réduira pas la fraction résultante lors d'un premier appel,
mais la réduira lors d'un appel subséquent lors de l'effectuation d'un
calcul sur trois fractions par la méthode
\f[B]calculate\-fractions\f[](Str:D $operation \[en]> Pair:D) {} Elle
renvoie une \f[B]paire\f[] constituée du numérateur et du dénominateur
de la fraction résultante.
.SS add\-upx2(Pair:D $pair1, Pair:D $pair2, Pair:D $pair3 \[en]> Pair:D)
.PP
Cette méthode renvoie l'addition des numérateurs et dénominateurs passés
aux attributs de la classe, c'est\-à\-dire, \f[B]nudepair1\f[],
\f[B]nudepair2\f[] et \f[B]nudepair3\f[], pour calculer la somme de
trois fractions.
Elle utilise les modules \f[B]ppcm.pm6\f[] et \f[B]pgcd.pm6\f[], ainsi
que la méthode de la classe : \f[B]reduce\-fraction($numerator,
$denominator)\f[].
Elle renvoie une \f[B]paire\f[] constituée par le numérateur et le
dénominateur de la fraction résultante.
.SS subtract(Pair:D $pair1, Pair:D $pair2, Int $times = 0 \[en]> Pair:D)
.PP
Cette méthode renvoie la soustraction des numérateurs et dénominateurs
passés aux attributs de la classe, c'est\-à\-dire, \f[B]nudepair1\f[] et
\f[B]nudepair2\f[].
Elle utilise les modules \f[B]ppcm.pm6\f[] et \f[B]pgcd.pm6\f[], ainsi
que la méthode de la classe \f[B]reduce\-fraction($numerator,
\f[BI]d\f[B]\f[BI]e\f[B]\f[BI]n\f[B]\f[BI]o\f[B]\f[BI]m\f[B]\f[BI]i\f[B]\f[BI]n\f[B]\f[BI]a\f[B]\f[BI]t\f[B]\f[BI]o\f[B]\f[BI]r\f[B]) *  * .\f[BI]L\f[B]\f[BI]e\f[B]\f[BI]p\f[B]\f[BI]a\f[B]\f[BI]r\f[B]\f[BI]a\f[B]\f[BI]m\f[B]\f[BI]è\f[B]\f[BI]t\f[B]\f[BI]r\f[B]\f[BI]e\f[B] * *times\f[]
a le même effet que pour l'opération \f[B]add\-up\f[] (voir plus haut).
Elle renvoie une paire constituée du numérateur et du dénominateur de la
fraction résultante.
.SS subtractx2(Pair:D $pair1, Pair:D $pair2, Pair:D $pair3 \[en]>
Pair:D)
.PP
Cette méthode renvoie la soustraction des numérateurs et dénominateurs
passés aux attributs de la classe, c'est\-à\-dire, \f[B]nudepair1\f[],
\f[B]nudepair2\f[] et \f[B]nudepair3\f[] pour calculer la différence de
trois fractions.
Elle utilise les modules \f[B]ppcm.pm6\f[] et \f[B]pgcd.pm6\f[], ainsi
que la méthode de la classe : \f[B]reduce\-fraction($numerator,
$denominator)\f[].
Elle renvoie une \f[B]paire\f[] constituée par le numérateur et le
dénominateur de la fraction résultante.
.SS add\-up\-subtract(Pair:D $pair1, Pair:D $pair2, Pair:D $pair3 \[en]>
Pair:D)
.PP
Cette méthode renvoie l'addition des numérateurs et dénominateurs passés
aux attributs de la classe, c'est\-à\-dire, \f[B]nudepair1\f[] et
\f[B]nudepair2\f[], et la soustraction des numérateurs et dénominateurs
passés à l'argument \f[B]nudepair3\f[] pour calculer la somme des deux
premières fractions et la différence du résultat et de la troisième
fraction.
Elle utilise les modules \f[B]ppcm.pm6\f[] et \f[B]pgcd.pm6\f[], ainsi
que la méthode de la classe : \f[B]reduce\-fraction($numerator,
$denominator)\f[].
Elle renvoie une \f[B]paire\f[] constituée par le numérateur et le
dénominateur de la fraction résultante.
.SS subtract\-add\-up(Pair:D $pair1, Pair:D $pair2, Pair $pair3:D \[en]>
Pair:D)
.PP
Cette méthode est l'inverse de la précédente, c'est\-à\-dire qu'elle
renvoie la soustraction des numérateurs et dénominateurs passés aux
attributs de la classe, c'est\-à\-dire, \f[B]nudepair1\f[],
\f[B]nudepair2\f[] pour calculer la différence des deux premières
fractions et la somme du résultat et de la troisième fraction dont
l'attribut de classe est \f[B]nudepair3\f[].
Elle utilise les modules \f[B]ppcm.pm6\f[] et \f[B]pgcd.pm6\f[], ainsi
que la méthode de la classe : \f[B]reduce\-fraction($numerator,
$denominator)\f[].
Elle renvoie une \f[B]paire\f[] constituée par le numérateur et le
dénominateur de la fraction résultante.
.SS breakdown\-factors(Int:D \@array\-of\-factors, Str:D $nu'de \[en]>
Array:D)
.PP
Cette méthode décompose un tableau de facteurs en facteurs premiers.
(remarquez le séparateur `du deuxième paramètre qui est parfaitement
valide en Perl 6). Elle utilise la méthode \f[B]breakdown\f[] du rôle
\f[B]PrimeFactors\f[]. L'argument \f[B]$nu'de\f[] peut contenir les
valeurs \f[B]nu\f[] ou \f[B]de\f[] (pour 'numerator'/`denominator') pour
indiquer à la fonction qu'elle doit retourner soit un tableau des
numérateurs, soit un tableau des dénominateurs.
Consultez la documentation du module \f[B]prime\-factors.pm6\f[] pour
plus d'informations.
.SS breakdown\-numerator(Int:D $numerator \[en]> Array:D)
.PP
Cette méthode permet d'ajouter de la granularité aux opérations en
réduisant en facteurs premiers uniquement le ou les numérateurs de
chaque fraction prise isolément.
Elle utilise les attributs \f[B]breakdown\-numerator1\f[] et/ou
\f[B]breakdown\-numerator2\f[] et/ou \f[B]breakdown\-numerator3\f[].
Si l'un de ces trois attributs est passé à b, cela désactivera
automatiquement l'attribut global \f[B]breakdown\-numerators\f[].
.SS breakdown\-denominator(Int:D $numerator \[en]> Array:D)
.PP
Cette méthode permet d'ajouter de la granularité aux opérations en
réduisant en facteurs premiers uniquement le ou les denominateurs de
chaque fraction prise isolément.
Elle utilise les attributs \f[B]breakdown\-denominator1\f[] et/ou
\f[B]breakdown\-denominator2\f[] et/ou \f[B]breakdown\-denominator3\f[].
Si l'un de ces trois attributs est passé à b, cela désactivera
automatiquement l'attribut global \f[B]breakdown\-denominators\f[].
.SS fractions\-product\-sign(Pair:D $p1, Pair $p2:D, Pair $p3? \[en]>
Str:D)
.PP
Cette méthode est utilisée pour déduire le signe du résultat du produit
des fractions passées en arguments aux attributs de la classe que sont
\f[B]nudepair1\f[], \f[B]nudepair2\f[] et facultativement
\f[B]nudepair3\f[] avant d'effectuer les calculs.
Cette méthode est employée uniquement pour des opérations de
\f[B]multiplication\f[] ou de \f[B]division\f[].
Elle retourne `+' ou `−' qui seront convertis en '`ou'\-' pour leur
utilisation effective.
.SS multiply(Pair:D $pair1, Pair:D $pair2, Pair $pair3? \[en]> Pair:D)
.PP
Cette méthode est utilisée pour multiplier deux ou trois fractions
données en arguments sous forme de paires numérateur => dénominateur
passées aux attributs de classe \f[B]nudepair1\f[], \f[B]nudepair2\f[]
et facultativement \f[B]nudepair3\f[].
Elle retourne une nouvelle \f[B]paire\f[].
.SS reduce\-fractions\-prime\-factors(Int:D \@numerators, Int:D
\@denominators, Int $return\-array = 1 \[en]> Array:D)
.PP
Cette méthode appartient au rôle \f[B]PrimeFactors\f[] : elle consiste à
produire les facteurs qui sont dans l'un des tableaux mais pas dans
l'autre.
Il faut passer l'argument 1 (c'est la valeur par défaut) à l'argument
\f[B]$return\-array\f[] pour retourner le premier tableau,
c'est\-à\-dire les numérateurs ou 2 pour retourner le deuxième tableau,
celui des dénominateurs.
Elle est implémentée ici directement dans le code et n'est donc pas
disponible comme méthode du module \f[B]operations\-on\-fractions\f[]
mais seulement comme méthode du module \f[B]prime\-factors.pm6\f[] dont
je rappelle qu'il définit le rôle \f[B]PrimeFactors\f[] employé par la
classe \f[B]OperationsOnFractions\f[].
Consultez aussi la documentation du module \f[B]prime\-factors.pm6\f[].
.SS divide(Pair:D $pair1, Pair:D $pair2 \[en]> Pair:D)
.PP
Cette méthode est utilisée pour diviser deux fractions données en
arguments sous forme de paires numérateur => dénominateur passées aux
attributs de classe \f[B]nudepair1\f[] et \f[B]nudepair2\f[].
Elle retourne une nouvelle \f[B]paire\f[].
Remarquez que l'attribut \f[B]nudepair3\f[] n'est pas utilisé
contrairement aux autres opérations et sera donc ignoré.
.SS deliver\-fraction\-sign(Int:D $key, Int:D $value \[en]> Str:D)
.PP
Cette méthode permet de distribuer le signe de chacune des fractions
prises isolément.
Elle est utilisée si l'un des attributs \f[B]reduce\-fraction1\f[] et/ou
\f[B]reduce\-fraction2\f[] et/ou \f[B]reduce\-fraction3\f[] sont passés
à \f[B]True\f[] dans la méthode \f[B]calculate\-fractions\f[](Str:D
$operation \[en]> Pair:D); je rappelle ici que ces trois champs sont à
\f[B]False\f[] par défaut.
